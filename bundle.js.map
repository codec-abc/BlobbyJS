{"version":3,"sources":["webpack:///webpack/bootstrap c3a8514f59f382d66404","webpack:///./src/Main.ts","webpack:///./src/views/screens/game/GameScreen.ts","webpack:///./src/views/screens/Screen.ts","webpack:///./src/views/ControlsManager.ts","webpack:///./src/views/screens/game/scene/GameScene.ts","webpack:///./src/views/screens/game/scene/SceneData.ts","webpack:///./src/views/screens/game/scene/SceneLoader.ts","webpack:///./src/views/screens/game/scene/GameForeground.ts","webpack:///./src/views/screens/game/interactive/PlayerView.ts","webpack:///./src/views/screens/game/GameResources.ts","webpack:///./src/controllers/PlayerController.ts","webpack:///./src/models/interactive/players/Player.ts","webpack:///./src/models/interactive/players/Behavior.ts","webpack:///./src/models/physics/KinematicBody.ts","webpack:///./src/models/physics/PhysicsEvents.ts","webpack:///./src/models/interactive/players/Jump.ts","webpack:///./src/models/interactive/players/Scoring.ts","webpack:///./src/views/screens/game/interactive/BallView.ts","webpack:///./src/utils/Geometry.ts","webpack:///./src/controllers/BallController.ts","webpack:///./src/models/interactive/balls/Ball.ts","webpack:///./src/models/interactive/balls/BallPhysics.ts","webpack:///./src/models/physics/RigidBody.ts","webpack:///./src/views/screens/game/interactive/NetView.ts","webpack:///./src/controllers/NetController.ts","webpack:///./src/models/interactive/net/Net.ts","webpack:///./src/controllers/OuterWallController.ts","webpack:///./src/models/interactive/net/OuterWall.ts","webpack:///./src/views/screens/game/scene/GameBackground.ts","webpack:///./src/utils/ElementData.ts","webpack:///./src/views/screens/game/scene/GameHUD.ts","webpack:///./src/models/physics/PhysicsEngine.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA,2BAA0B;;;;;;;ACP1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,4EAA4E;AAC7E;;;;;;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA,gCAA+B,aAAa;AAC5C;AACA;AACA,iBAAgB,OAAO;AACvB;AACA,iCAAgC,YAAY;AAC5C;AACA;AACA,iBAAgB,OAAO;AACvB;AACA,yBAAwB,yDAAyD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,qBAAoB,wBAAwB;AAC5C,6BAA4B,oCAAoC;AAChE;AACA,iBAAgB,oBAAoB;AACpC,qBAAoB,4BAA4B;AAChD;AACA,wBAAuB,2BAA2B;AAClD,8BAA6B,6BAA6B;AAC1D;AACA,qBAAoB,wBAAwB;AAC5C,0BAAyB,yBAAyB;AAClD;AACA,oBAAmB,uBAAuB;AAC1C,2BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,qBAAqB;AAC7D;AACA,gCAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,4BAA4B;AACrE;AACA,4CAA2C,8BAA8B;AACzE;AACA,yCAAwC,2BAA2B;AACnE;AACA,2CAA0C,6BAA6B;AACvE;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,qBAAqB;AAC7D;AACA,oCAAmC,YAAY;AAC/C;AACA,qCAAoC,YAAY;AAChD;AACA,4BAA2B,UAAU;AACrC,yCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,2CAA2C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B,iBAAgB,eAAe;AAC/B,iBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,eAAe;AAC/B,iBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,qBAAoB,wBAAwB;AAC5C,6BAA4B,oCAAoC;AAChE;AACA,iBAAgB,oBAAoB;AACpC,qBAAoB,4BAA4B;AAChD;AACA,wBAAuB,2BAA2B;AAClD,8BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,aAAa;AACtC;AACA,iCAAgC,YAAY;AAC5C;AACA,gCAA+B,YAAY;AAC3C;AACA,mCAAkC,UAAU;AAC5C;AACA,kCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,wBAAwB;AAC5C;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA,yBAAwB,UAAU;AAClC;AACA;AACA,iBAAgB,OAAO;AACvB;AACA,0BAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,aAAa;AACxC;AACA,gCAA+B,YAAY;AAC3C;AACA,iCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,eAAe;AAC/B,iBAAgB,WAAW;AAC3B,iBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"build/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c3a8514f59f382d66404","/// <reference path=\"../typings/node/node.d.ts\"/>\n\"use strict\";\nconst GameScreen = require(\"./views/screens/game/GameScreen\");\nlet gameScreen = new GameScreen.GameScreen();\nwindow.gameScreen = gameScreen; // set the game in a gameScreen property for debugging purpose\nvar isRunningInElectron = window.isRunningInElectron;\nvar modules = window.nodeModules;\nif (isRunningInElectron) { }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Main.ts\n// module id = 0\n// module chunks = 0","/// <reference path=\"../../../../typings/jquery/jquery.d.ts\"/>\n\"use strict\";\nconst ScreenBase = require(\"../Screen\");\nconst GameSceneModule = require(\"./scene/GameScene\");\nconst GameSceneLoaderModule = require(\"./scene/SceneLoader\");\nconst ControlsManager = require(\"../../ControlsManager\");\nlet Controls = ControlsManager.ControlsManager;\nlet Keyboard = ControlsManager.KeyboardControl;\nlet Mouse = ControlsManager.MouseControl;\n/**\n * @brief   Game screen in which players can play.\n */\nclass GameScreen extends ScreenBase.Screen {\n    /**\n     * @brief   Creation of the GameScreen.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * @brief   Set up the screen.\n     */\n    setup() {\n        this.m_scene = new GameSceneModule.GameScene();\n        addEventListener(GameSceneLoaderModule.GameSceneLoader.SceneLoadedEvent, this.onSceneLoaded.bind(this));\n        this.m_intervalHandle = setInterval(this.frameTick.bind(this), 1000 / 60);\n    }\n    /**\n     * @brief   Set up controls once the scene is loaded.\n     */\n    onSceneLoaded() {\n        this.setupControls();\n    }\n    frameTick() {\n        this.m_scene.update();\n        this.update();\n    }\n    /**\n     * @brief   Set up controls (keyboard, mouse).\n     */\n    setupControls() {\n        var leftPlayer = this.m_scene.LeftPlayer;\n        this.addKeyboardCallback(Keyboard.Key_S, leftPlayer.moveLeft.bind(leftPlayer));\n        this.addKeyboardCallback(Keyboard.Key_F, leftPlayer.moveRight.bind(leftPlayer));\n        this.addKeyboardCallback(Keyboard.Key_E, leftPlayer.jump.bind(leftPlayer));\n        var rightPlayer = this.m_scene.RightPlayer;\n        this.addKeyboardCallback(Keyboard.LeftArrow, rightPlayer.moveLeft.bind(rightPlayer));\n        this.addKeyboardCallback(Keyboard.RightArrow, rightPlayer.moveRight.bind(rightPlayer));\n        this.addKeyboardCallback(Keyboard.UpArrow, rightPlayer.jump.bind(rightPlayer));\n    }\n}\nexports.GameScreen = GameScreen;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/GameScreen.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nconst ControlsManager = require(\"../ControlsManager\");\nlet Controls = ControlsManager.ControlsManager;\n/**\n * @brief   Abstract class that represents screens.\n */\nclass Screen {\n    /**\n     * @brief   Create a new Screen.\n     */\n    constructor() {\n        this.m_controls = new Controls();\n        this.setup();\n    }\n    /**\n     * @brief   Add control from keyboard.\n     * @param   key         Keyboard key to bind to an action.\n     * @param   callback    Function to be called when the key is pressed.\n     */\n    addKeyboardCallback(key, callback) {\n        this.m_controls.addKeyboardCallback(key, callback);\n    }\n    /**\n     * @brief   Add control from mouse.\n     * @param   mouse       Mouse button to bind to an action.\n     * @param   callback    Function to be called when the key is pressed.\n     */\n    addMouseCallback(mouse, callback) {\n        this.m_controls.addMouseCallback(mouse, callback);\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        this.m_controls.update();\n    }\n}\nexports.Screen = Screen;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/Screen.ts\n// module id = 2\n// module chunks = 0","/// <reference path=\"../../typings/jquery/jquery.d.ts\"/>\n\"use strict\";\n;\nclass ControlsManager {\n    /**\n     * @brief   Creation of a ControlsManager.\n     */\n    constructor() {\n        /** @brief  List of all avalaible keyboard controls with their callback. */\n        this.m_keyboardCallbacks = {};\n        /** @brief  List of all avalaible mouse controls with their callback. */\n        this.m_mouseCallbacks = {};\n        /** @brief  List of active keyboard controls (key pressed). */\n        this.m_activeKeyboardControls = new Array();\n        /** @brief  List of active mouse controls (key pressed). */\n        this.m_activeMouseControls = new Array();\n        this.setupKeyboard();\n        this.setupMouse();\n    }\n    /**\n     * @brief   Set up keyboard controls.\n     */\n    setupKeyboard() {\n        var self = this;\n        // Only keydown is supported at the moment.\n        $(window).keydown(function (e) {\n            var controlCode = e.which;\n            var validControl;\n            validControl = ControlsManager.CheckValidKeyboardControl(controlCode);\n            if (validControl) {\n                var inArrayPos = self.m_activeKeyboardControls.indexOf(controlCode);\n                var controlCallback = self.m_keyboardCallbacks[controlCode];\n                var hasCallback = (controlCallback !== undefined);\n                // Insert value if not in array.\n                if (hasCallback && (inArrayPos < 0)) {\n                    self.m_activeKeyboardControls.push(controlCode);\n                }\n            }\n            e.preventDefault();\n        });\n        // Remove the key from the pressed ones when it is released.\n        $(window).keyup(function (e) {\n            var controlCode = e.which;\n            var inArrayPos = self.m_activeKeyboardControls.indexOf(controlCode);\n            if (inArrayPos > -1) {\n                // Erase the value.\n                self.m_activeKeyboardControls.splice(inArrayPos, 1);\n            }\n        });\n    }\n    /**\n     * @brief   Set up mouse controls.\n     */\n    setupMouse() {\n        var self = this;\n        // Mouse buttons.\n        $(window).mousedown(function (e) {\n            var controlCode = e.which;\n            var validControl;\n            validControl = ControlsManager.CheckValidMouseControl(controlCode);\n            if (validControl) {\n                var controlCallback;\n                controlCallback = self.m_mouseCallbacks[controlCode];\n                if (controlCallback != undefined) {\n                    controlCallback();\n                }\n            }\n        });\n    }\n    /**\n     * @brief   Loop to have smooth animations when using keyboard.\n     */\n    keyboardLoop() {\n        var self = this;\n        this.m_activeKeyboardControls.forEach(function (element, index, array) {\n            self.m_keyboardCallbacks[element]();\n        });\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        this.keyboardLoop();\n    }\n    /**\n     * @brief   Add a keyboard control with its callback.\n     * @param   key         Keyboard key to bind to an action.\n     * @param   callback    Function to be called when the key is pressed.\n     * @warning Replace the previous callback if already defined for the\n     *          provided control.\n     */\n    addKeyboardCallback(key, callback) {\n        this.m_keyboardCallbacks[key] = callback;\n    }\n    /**\n     * @brief   Add a mouse control with its callback.\n     * @param   mouse       Mouse button to bind to an action.\n     * @param   callback    Function to be called when the key is pressed.\n     * @warning Replace the previous callback if already defined for the\n     *          provided control.\n     */\n    addMouseCallback(mouse, callback) {\n        this.m_mouseCallbacks[mouse] = callback;\n    }\n    /**\n     * @brief   Check if the given value is defined in the keyboard controls\n     *          enumeration.\n     * @param   value   Value to check.\n     * @warning TRUE if the value exists, FALSE else.\n     */\n    static CheckValidKeyboardControl(value) {\n        return KeyboardControl[value] != undefined;\n    }\n    /**\n     * @brief   Check if the given value is defined in the mouse controls\n     *          enumeration.\n     * @param   value   Value to check.\n     * @warning TRUE if the value exists, FALSE else.\n     */\n    static CheckValidMouseControl(value) {\n        return MouseControl[value] != undefined;\n    }\n}\nexports.ControlsManager = ControlsManager;\n;\n/** @brief  Represent mouse button codes with more readable values. */\nvar MouseControl;\n(function (MouseControl) {\n    MouseControl[MouseControl[\"LeftButton\"] = 0] = \"LeftButton\";\n    MouseControl[MouseControl[\"MiddleButton\"] = 1] = \"MiddleButton\";\n    MouseControl[MouseControl[\"RightButton\"] = 2] = \"RightButton\";\n    MouseControl[MouseControl[\"AmountMouseControls\"] = 3] = \"AmountMouseControls\";\n})(MouseControl = exports.MouseControl || (exports.MouseControl = {}));\n;\n/** @brief  Represent keyboard key codes with more readable values. */\nvar KeyboardControl;\n(function (KeyboardControl) {\n    KeyboardControl[KeyboardControl[\"Backspace\"] = 8] = \"Backspace\";\n    KeyboardControl[KeyboardControl[\"Tabulation\"] = 9] = \"Tabulation\";\n    KeyboardControl[KeyboardControl[\"Enter\"] = 13] = \"Enter\";\n    KeyboardControl[KeyboardControl[\"Shift\"] = 16] = \"Shift\";\n    KeyboardControl[KeyboardControl[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardControl[KeyboardControl[\"Alt\"] = 18] = \"Alt\";\n    KeyboardControl[KeyboardControl[\"Escape\"] = 27] = \"Escape\";\n    KeyboardControl[KeyboardControl[\"PageUp\"] = 33] = \"PageUp\";\n    KeyboardControl[KeyboardControl[\"PageDown\"] = 34] = \"PageDown\";\n    KeyboardControl[KeyboardControl[\"End\"] = 35] = \"End\";\n    KeyboardControl[KeyboardControl[\"Home\"] = 36] = \"Home\";\n    KeyboardControl[KeyboardControl[\"LeftArrow\"] = 37] = \"LeftArrow\";\n    KeyboardControl[KeyboardControl[\"UpArrow\"] = 38] = \"UpArrow\";\n    KeyboardControl[KeyboardControl[\"RightArrow\"] = 39] = \"RightArrow\";\n    KeyboardControl[KeyboardControl[\"DownArrow\"] = 40] = \"DownArrow\";\n    KeyboardControl[KeyboardControl[\"Insert\"] = 45] = \"Insert\";\n    KeyboardControl[KeyboardControl[\"Delete\"] = 46] = \"Delete\";\n    KeyboardControl[KeyboardControl[\"Key_0\"] = 48] = \"Key_0\";\n    KeyboardControl[KeyboardControl[\"Key_1\"] = 49] = \"Key_1\";\n    KeyboardControl[KeyboardControl[\"Key_2\"] = 50] = \"Key_2\";\n    KeyboardControl[KeyboardControl[\"Key_3\"] = 51] = \"Key_3\";\n    KeyboardControl[KeyboardControl[\"Key_4\"] = 52] = \"Key_4\";\n    KeyboardControl[KeyboardControl[\"Key_5\"] = 53] = \"Key_5\";\n    KeyboardControl[KeyboardControl[\"Key_6\"] = 54] = \"Key_6\";\n    KeyboardControl[KeyboardControl[\"Key_7\"] = 55] = \"Key_7\";\n    KeyboardControl[KeyboardControl[\"Key_8\"] = 56] = \"Key_8\";\n    KeyboardControl[KeyboardControl[\"Key_9\"] = 57] = \"Key_9\";\n    KeyboardControl[KeyboardControl[\"Key_A\"] = 65] = \"Key_A\";\n    KeyboardControl[KeyboardControl[\"Key_B\"] = 66] = \"Key_B\";\n    KeyboardControl[KeyboardControl[\"Key_C\"] = 67] = \"Key_C\";\n    KeyboardControl[KeyboardControl[\"Key_D\"] = 68] = \"Key_D\";\n    KeyboardControl[KeyboardControl[\"Key_E\"] = 69] = \"Key_E\";\n    KeyboardControl[KeyboardControl[\"Key_F\"] = 70] = \"Key_F\";\n    KeyboardControl[KeyboardControl[\"Key_G\"] = 71] = \"Key_G\";\n    KeyboardControl[KeyboardControl[\"Key_H\"] = 72] = \"Key_H\";\n    KeyboardControl[KeyboardControl[\"Key_I\"] = 73] = \"Key_I\";\n    KeyboardControl[KeyboardControl[\"Key_J\"] = 74] = \"Key_J\";\n    KeyboardControl[KeyboardControl[\"Key_K\"] = 75] = \"Key_K\";\n    KeyboardControl[KeyboardControl[\"Key_L\"] = 76] = \"Key_L\";\n    KeyboardControl[KeyboardControl[\"Key_M\"] = 77] = \"Key_M\";\n    KeyboardControl[KeyboardControl[\"Key_N\"] = 78] = \"Key_N\";\n    KeyboardControl[KeyboardControl[\"Key_O\"] = 79] = \"Key_O\";\n    KeyboardControl[KeyboardControl[\"Key_P\"] = 80] = \"Key_P\";\n    KeyboardControl[KeyboardControl[\"Key_Q\"] = 81] = \"Key_Q\";\n    KeyboardControl[KeyboardControl[\"Key_R\"] = 82] = \"Key_R\";\n    KeyboardControl[KeyboardControl[\"Key_S\"] = 83] = \"Key_S\";\n    KeyboardControl[KeyboardControl[\"Key_T\"] = 84] = \"Key_T\";\n    KeyboardControl[KeyboardControl[\"Key_U\"] = 85] = \"Key_U\";\n    KeyboardControl[KeyboardControl[\"Key_V\"] = 86] = \"Key_V\";\n    KeyboardControl[KeyboardControl[\"Key_W\"] = 87] = \"Key_W\";\n    KeyboardControl[KeyboardControl[\"Key_X\"] = 88] = \"Key_X\";\n    KeyboardControl[KeyboardControl[\"Key_Y\"] = 89] = \"Key_Y\";\n    KeyboardControl[KeyboardControl[\"Key_Z\"] = 90] = \"Key_Z\";\n    KeyboardControl[KeyboardControl[\"Numpad_0\"] = 96] = \"Numpad_0\";\n    KeyboardControl[KeyboardControl[\"Numpad_1\"] = 97] = \"Numpad_1\";\n    KeyboardControl[KeyboardControl[\"Numpad_2\"] = 98] = \"Numpad_2\";\n    KeyboardControl[KeyboardControl[\"Numpad_3\"] = 99] = \"Numpad_3\";\n    KeyboardControl[KeyboardControl[\"Numpad_4\"] = 100] = \"Numpad_4\";\n    KeyboardControl[KeyboardControl[\"Numpad_5\"] = 101] = \"Numpad_5\";\n    KeyboardControl[KeyboardControl[\"Numpad_6\"] = 102] = \"Numpad_6\";\n    KeyboardControl[KeyboardControl[\"Numpad_7\"] = 103] = \"Numpad_7\";\n    KeyboardControl[KeyboardControl[\"Numpad_8\"] = 104] = \"Numpad_8\";\n    KeyboardControl[KeyboardControl[\"Numpad_9\"] = 105] = \"Numpad_9\";\n    KeyboardControl[KeyboardControl[\"Numpad_Mul\"] = 106] = \"Numpad_Mul\";\n    KeyboardControl[KeyboardControl[\"Numpad_Add\"] = 107] = \"Numpad_Add\";\n    KeyboardControl[KeyboardControl[\"Numpad_Sub\"] = 108] = \"Numpad_Sub\";\n    KeyboardControl[KeyboardControl[\"Numpad_Point\"] = 109] = \"Numpad_Point\";\n    KeyboardControl[KeyboardControl[\"Numpad_Divide\"] = 110] = \"Numpad_Divide\";\n    KeyboardControl[KeyboardControl[\"AmountKeyboardControls\"] = 111] = \"AmountKeyboardControls\";\n})(KeyboardControl = exports.KeyboardControl || (exports.KeyboardControl = {}));\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/ControlsManager.ts\n// module id = 3\n// module chunks = 0","/// <reference path=\"../../../../../typings/jquery/jquery.d.ts\"/>\n/// <reference path=\"../../../../../typings/pixi/pixi.js.d.ts\"/>\n\"use strict\";\nconst SceneDataModule = require(\"./SceneData\");\nconst SceneLoaderModule = require(\"./SceneLoader\");\nconst ResourcesModule = require(\"../GameResources\");\nconst PhysicsEngineModule = require(\"../../../../models/physics/PhysicsEngine\");\nlet Resources = ResourcesModule.GameResources;\nlet PhysicsEngine = PhysicsEngineModule.PhysicsEngine;\n/**\n * @brief   Scene of the game stage.\n */\nclass GameScene extends PIXI.Container {\n    /**\n     * Get the initial width of the scene.\n     * @return {number} Initial width of the scene.\n     */\n    static get InitialWidth() { return 1024; }\n    /**\n     * Get the initial height of the scene.\n     * @return {number} Initial height of the scene.\n     */\n    static get InitialHeight() { return 576; }\n    /**\n     * Get the ratio to correctly render the renderer.\n     * @return {number} Ratio width / height of the scene.\n     */\n    static get Ratio() { return GameScene.InitialWidth / GameScene.InitialHeight; }\n    /**\n     * @brief   Create a new GameScene.\n     */\n    constructor() {\n        super();\n        this.m_hasSceneFinishedLoading = false;\n        var width = GameScene.InitialWidth;\n        var height = GameScene.InitialHeight;\n        this.m_physicsEngine = new PhysicsEngineModule.PhysicsEngine();\n        this.m_sceneData = new SceneDataModule.SceneData(width, height);\n        this.m_sceneLoader = new SceneLoaderModule.GameSceneLoader(this.m_sceneData);\n        addEventListener(SceneLoaderModule.GameSceneLoader.SceneLoadedEvent, this.onSceneLoaded.bind(this));\n        this.m_renderer = PIXI.autoDetectRenderer(width, height);\n        $(window).resize(this.onResizedWindow.bind(this));\n        this.onResizedWindow();\n        var parentContainer = $('#GameCanvas');\n        parentContainer.append(this.m_renderer.view);\n    }\n    onResizedWindow() {\n        var currentRatio = $(window).innerWidth() / $(window).innerHeight();\n        if (currentRatio >= GameScene.Ratio) {\n            var width = $(window).innerHeight() * GameScene.Ratio;\n            var height = $(window).innerHeight();\n        }\n        else {\n            var width = $(window).innerWidth();\n            var height = $(window).innerWidth() / GameScene.Ratio;\n        }\n        this.m_renderer.view.style.width = width + 'px';\n        this.m_renderer.view.style.height = height + 'px';\n    }\n    /**\n     * @brief   Callback when scene is loaded.\n     */\n    onSceneLoaded() {\n        this.addChild(this.m_sceneLoader.Background);\n        this.addChild(this.m_sceneLoader.Foreground);\n        this.addChild(this.m_sceneLoader.HUD);\n        this.m_hasSceneFinishedLoading = true;\n    }\n    /**\n     * @brief   Update the animation of the scene.\n     */\n    animate() {\n        if (this.m_hasSceneFinishedLoading) {\n            this.m_physicsEngine.update();\n            this.m_sceneLoader.Foreground.update();\n            this.m_sceneLoader.HUD.update();\n            this.m_renderer.render(this);\n        }\n    }\n    /*\n     * @brief   Get the left player.\n     */\n    get LeftPlayer() {\n        return this.m_sceneLoader.Foreground.LeftPlayer;\n    }\n    /*\n     * @brief   Get the right player.\n     */\n    get RightPlayer() {\n        return this.m_sceneLoader.Foreground.RightPlayer;\n    }\n    /**\n      * @brief   Update the object.\n      */\n    update() {\n        this.animate();\n    }\n}\nexports.GameScene = GameScene;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/GameScene.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\n/**\n * @brief   Shared scene data.\n */\nclass SceneData {\n    /** @brief  Offset from bottom of the scene to make players be on ground. */\n    static get PlayersOffset() { return 32; }\n    /**\n     * @brief   Create a new instance of the SceneData.\n     */\n    constructor(width, height) {\n        this.m_width = width;\n        this.m_height = height;\n    }\n    /** @brief  Get the width of the scene. */\n    get Width() { return this.m_width; }\n    /** @brief  Get the height of the scene. */\n    get Height() { return this.m_height; }\n}\nexports.SceneData = SceneData;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/SceneData.ts\n// module id = 5\n// module chunks = 0","/// <reference path=\"../../../../../typings/pixi/pixi.js.d.ts\"/>\n\"use strict\";\nconst GameForegroundModule = require(\"./GameForeground\");\nconst GameBackgroundModule = require(\"./GameBackground\");\nconst GameHUDModule = require(\"./GameHUD\");\nclass GameSceneLoader {\n    /**\n     * @brief   Create the GameSceneLoader.\n     * @param   sceneData   Data required to generate the scene.\n     */\n    constructor(sceneData) {\n        /** @brief  Flag to know if foreground is loaded. */\n        this.m_isLoadedForeground = false;\n        /** @brief  Flag to know if background is loaded. */\n        this.m_isLoadedBackground = false;\n        /** @brief  Flag to know if background is loaded. */\n        this.m_isLoadedHUD = false;\n        this.loadBackground(sceneData);\n        this.loadForeground(sceneData);\n        this.loadHUD(sceneData);\n    }\n    /** @brief  Event sent when the scene is loaded. */\n    static get SceneLoadedEvent() {\n        return 'SceneLoaded';\n    }\n    /**\n     * @brief   Load the foreground.\n     * @param   sceneData   Data required to generate the scene.\n     */\n    loadForeground(sceneData) {\n        const ForegroundLoaded = GameForegroundModule.GameForeground.ForegroundLoadedEvent;\n        addEventListener(ForegroundLoaded, this.onLoadedForeground.bind(this));\n        this.m_foreground = new GameForegroundModule.GameForeground(sceneData);\n    }\n    /**\n     * @brief   Trigger operations once foreground is fully loaded.\n     */\n    onLoadedForeground() {\n        this.m_isLoadedForeground = true;\n        this.notifyIfSceneLoaded();\n        const ForegroundLoaded = GameForegroundModule.GameForeground.ForegroundLoadedEvent;\n        removeEventListener(ForegroundLoaded, this.onLoadedForeground.bind(this));\n    }\n    /**\n     * @brief   Load the background.\n     * @param   sceneData   Data required to generate the scene.\n     */\n    loadBackground(sceneData) {\n        const BackgroundLoaded = GameBackgroundModule.GameBackground.BackgroundLoadedEvent;\n        addEventListener(BackgroundLoaded, this.onLoadedBackground.bind(this));\n        this.m_background = new GameBackgroundModule.GameBackground(sceneData.Width, sceneData.Height);\n    }\n    /**\n     * @brief   Trigger operations once foreground is fully loaded.\n     */\n    onLoadedBackground() {\n        this.m_isLoadedBackground = true;\n        this.notifyIfSceneLoaded();\n        const BackgroundLoaded = GameBackgroundModule.GameBackground.BackgroundLoadedEvent;\n        removeEventListener(BackgroundLoaded, this.onLoadedBackground.bind(this));\n    }\n    /**\n     * @brief   Load the game HUD.\n     * @param   sceneData   Data required to generate the scene.\n     */\n    loadHUD(sceneData) {\n        const HUDLoaded = GameHUDModule.GameHUD.HUDLoadedEvent;\n        addEventListener(HUDLoaded, this.onLoadedHUD.bind(this));\n        this.m_hud = new GameHUDModule.GameHUD(sceneData.Width);\n    }\n    /**\n     * @brief   Trigger operations once HUD is fully loaded.\n     */\n    onLoadedHUD() {\n        this.m_isLoadedHUD = true;\n        this.notifyIfSceneLoaded();\n        const HUDLoaded = GameHUDModule.GameHUD.HUDLoadedEvent;\n        removeEventListener(HUDLoaded, this.onLoadedHUD.bind(this));\n    }\n    /**\n     * @brief   Notify listeners that the scene has been fully loaded.\n     * */\n    notifyIfSceneLoaded() {\n        if (this.m_isLoadedForeground\n            && this.m_isLoadedBackground\n            && this.m_isLoadedHUD) {\n            // Notify the scene is loaded.\n            dispatchEvent(new Event(GameSceneLoader.SceneLoadedEvent));\n        }\n    }\n    /** @brief  Foreground of the scene. */\n    get Foreground() {\n        return this.m_foreground;\n    }\n    /** @brief  Background of the scene. */\n    get Background() {\n        return this.m_background;\n    }\n    /** @brief  HUD of the scene. */\n    get HUD() {\n        return this.m_hud;\n    }\n}\nexports.GameSceneLoader = GameSceneLoader;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/SceneLoader.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nconst SceneDataModule = require(\"./SceneData\");\nconst PlayerViewModule = require(\"../interactive/PlayerView\");\nconst PlayerControllerModule = require(\"../../../../controllers/PlayerController\");\nconst BallViewModule = require(\"../interactive/BallView\");\nconst BallControllerModule = require(\"../../../../controllers/BallController\");\nconst NetViewModule = require(\"../interactive/NetView\");\nconst NetControllerModule = require(\"../../../../controllers/NetController\");\nconst OuterWallControllerModule = require(\"../../../../controllers/OuterWallController\");\nclass GameForeground extends PIXI.Container {\n    /** @brief  Event sent when the foreground is loaded. */\n    static get ForegroundLoadedEvent() {\n        return 'ForegroundLoaded';\n    }\n    /**\n     * @brief   Create a new instance of GameForeground.\n     */\n    constructor(data) {\n        super();\n        this.m_sceneData = data;\n        this.m_outerWalls = new Array();\n        // Be sure the net is loaded before players.\n        NetViewModule.NetView.PreloadSprites();\n        addEventListener(NetViewModule.NetView.NetLoadedEvent, this.onLoadedNet.bind(this));\n    }\n    onLoadedNet() {\n        // Texture of the net.\n        var netTexture = PIXI.Texture.fromImage(NetViewModule.NetView.NetPath);\n        // Position of the net.\n        var netPosition = new PIXI.Point((this.m_sceneData.Width / 2) - netTexture.width, this.m_sceneData.Height - netTexture.height - 20);\n        // Setup the net.\n        var data;\n        data = new NetControllerModule.NetSetupData(netPosition, netTexture);\n        this.m_net = new NetControllerModule.NetController(data);\n        this.addChild(this.m_net.View.NetSprite);\n        // Set up the outer walls.\n        this.setupOuterWalls();\n        // Load and set players.\n        PlayerViewModule.PlayerView.PreloadSprites();\n        addEventListener(PlayerViewModule.PlayerView.PlayersLoadedEvent, this.onLoadedPlayers.bind(this));\n        // Load and set the ball.\n        BallViewModule.BallView.PreloadSprites();\n        addEventListener(BallViewModule.BallView.BallLoadedEvent, this.onLoadedBall.bind(this));\n    }\n    /**NetPosition - NetWidth\n     * @brief   Creation of the Players when their relative data are fully\n     *          loaded.\n     */\n    onLoadedPlayers() {\n        const SceneWidth = this.m_sceneData.Width;\n        const NetPosition = this.m_net.View.NetSprite.x;\n        const NetWidth = this.m_net.View.NetSprite.width;\n        const PositionXStep = SceneWidth / 4;\n        const PositionY = this.m_sceneData.Height - SceneDataModule.SceneData.PlayersOffset;\n        // Set up the left player.\n        {\n            const TexturePlayer = PlayerViewModule.PlayerView.LeftPlayerPath;\n            let playerData;\n            playerData = GameForeground.PlayerData;\n            // Compute the area in which the player can move.\n            var areaX = 0;\n            var areaY = 0;\n            var areaWidth = NetPosition;\n            var areaHeight = this.m_sceneData.Height;\n            playerData.Area = new PIXI.Rectangle(areaX, areaY, areaWidth, areaHeight);\n            playerData.Position = new PIXI.Point(PositionXStep, PositionY);\n            playerData.Texture = PIXI.Texture.fromImage(TexturePlayer);\n            this.m_leftPlayer = new PlayerControllerModule.PlayerController(playerData);\n            this.addChild(this.m_leftPlayer.View.ShadowSprite);\n            this.addChild(this.m_leftPlayer.View.PlayerSprite);\n        }\n        // Set up the right player.\n        {\n            const TexturePlayer = PlayerViewModule.PlayerView.RightPlayerPath;\n            let playerData;\n            playerData = GameForeground.PlayerData;\n            // Compute the area in which the player can move.\n            var areaX = NetPosition + NetWidth;\n            var areaY = 0;\n            var areaWidth = (SceneWidth / 2) - (NetWidth / 2);\n            var areaHeight = this.m_sceneData.Height;\n            playerData.Area = new PIXI.Rectangle(areaX, areaY, areaWidth, areaHeight);\n            playerData.Position = new PIXI.Point(PositionXStep * 3, PositionY);\n            playerData.Texture = PIXI.Texture.fromImage(TexturePlayer);\n            this.m_rightPlayer = new PlayerControllerModule.PlayerController(playerData);\n            this.addChild(this.m_rightPlayer.View.ShadowSprite);\n            this.addChild(this.m_rightPlayer.View.PlayerSprite);\n        }\n        // Notify the foreground is loaded and ready to be updated/rendered.\n        dispatchEvent(new Event(GameForeground.ForegroundLoadedEvent));\n    }\n    /**\n    * @brief   Creation of the Ball when its data are loaded.\n    */\n    onLoadedBall() {\n        const PositionY = this.m_sceneData.Height - SceneDataModule.SceneData.PlayersOffset;\n        const BallTexture = BallViewModule.BallView.BallPath;\n        let ballData;\n        ballData = new BallControllerModule.BallSetupData();\n        ballData.Position = new PIXI.Point(0, PositionY);\n        ;\n        ballData.SpeedFactor = 5;\n        ballData.Area = new PIXI.Rectangle(0, 0, this.m_sceneData.Width, PositionY);\n        this.m_ball = new BallControllerModule.BallController(ballData);\n        this.addChild(this.m_ball.View.ShadowSprite);\n        this.addChild(this.m_ball.View.BallSprite);\n        this.m_ball.reset(new PIXI.Point(250, 120));\n    }\n    /**\n     * Set up the outer walls of the game area.\n     */\n    setupOuterWalls() {\n        var leftWallPosition = new PIXI.Point(0, -this.m_sceneData.Height);\n        var leftOuterWall = new OuterWallControllerModule.OuterWallController(leftWallPosition);\n        this.m_outerWalls.push(leftOuterWall);\n        var rightWallPosition = new PIXI.Point(this.m_sceneData.Width, -this.m_sceneData.Height);\n        var rightOuterWall = new OuterWallControllerModule.OuterWallController(rightWallPosition);\n        this.m_outerWalls.push(rightOuterWall);\n    }\n    /**\n     * @brief   Get a Player data.\n     * @return  A new Player data.\n     */\n    static get PlayerData() {\n        let playerData;\n        playerData = new PlayerControllerModule.PlayerSetupData();\n        playerData.SpeedFactor = 1;\n        playerData.MaxScore = 15;\n        return playerData;\n    }\n    /**\n     * @brief   Get the left player.\n     */\n    get LeftPlayer() {\n        return this.m_leftPlayer;\n    }\n    /**\n     * @brief   Get the right player.\n     */\n    get RightPlayer() {\n        return this.m_rightPlayer;\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        if (this.m_leftPlayer) {\n            this.m_leftPlayer.update();\n        }\n        if (this.m_rightPlayer) {\n            this.m_rightPlayer.update();\n        }\n        if (this.m_ball) {\n            this.m_ball.update();\n        }\n    }\n}\nexports.GameForeground = GameForeground;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/GameForeground.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nconst ResourcesModule = require(\"../GameResources\");\nlet Resources = ResourcesModule.GameResources;\n/**\n * @brief   Graphical representation of a Player.\n */\nclass PlayerView {\n    /** @brief  Event sent when the players data are loaded. */\n    static get PlayersLoadedEvent() {\n        return 'PlayersLoaded';\n    }\n    /** @brief  Path to the sprite texture of the left player. */\n    static get LeftPlayerPath() {\n        return Resources.ImagesFolder + '/LeftPlayer.png';\n    }\n    /** @brief  Path to the sprite texture of the right player. */\n    static get RightPlayerPath() {\n        return Resources.ImagesFolder + '/RightPlayer.png';\n    }\n    /**\n     * @brief  Create a new instance of the PlayerView.\n     * @param   texture     Texture of the PlayerView.\n     * @param   position    Position of the PlayerView sprite when created.\n     */\n    constructor(texture, position) {\n        this.m_playerSprite = new PIXI.Sprite(texture);\n        this.m_shadowSprite = new PIXI.Sprite(Resources.ShadowTexture);\n        this.m_shadowSprite.position.y = position.y + (this.m_playerSprite.height * 0.62);\n        this.moveAt(position);\n    }\n    /** @brief  Preload players textures in order to synchronize loadings. */\n    static PreloadSprites() {\n        var assetsLoader = new PIXI.loaders.Loader();\n        assetsLoader.add('FirstPlayer', PlayerView.LeftPlayerPath);\n        assetsLoader.add('SecondPlayer', PlayerView.RightPlayerPath);\n        assetsLoader.add('Shadow', Resources.ShadowPath);\n        assetsLoader.once('complete', PlayerView.OnAssetsLoaded);\n        assetsLoader.load();\n    }\n    /**\n     * @brief   Send an event to the game view once all resources on PlayerViews\n     *          are loaded.\n     */\n    static OnAssetsLoaded() {\n        Resources.ShadowTexture = PIXI.Texture.fromImage(Resources.ShadowPath);\n        PlayerView.ShadowXOffset = Resources.ShadowTexture.width / 3.5;\n        dispatchEvent(new Event(PlayerView.PlayersLoadedEvent));\n    }\n    /**\n     * @brief   Move the sprite of the PlayerView at the given position.\n     * @param   position    Position of the sprite.\n     */\n    moveAt(position) {\n        this.m_playerSprite.position.x = position.x;\n        this.m_playerSprite.position.y = position.y;\n        // Adjust the shadow sprite position to the player sprite.\n        this.m_shadowSprite.position.x = position.x - PlayerView.ShadowXOffset;\n        this.m_shadowSprite.alpha = this.m_shadowSprite.alpha = Math.max(0.2, position.y / this.m_shadowSprite.position.y);\n    }\n    /**\n     * @brief   Get sprite of the Player.\n     * @return  Sprite of the Player.\n     */\n    get PlayerSprite() {\n        return this.m_playerSprite;\n    }\n    /**\n     * @brief   Get sprite of the Player shadow.\n     * @return  Sprite of the Player shadow.\n     */\n    get ShadowSprite() {\n        return this.m_shadowSprite;\n    }\n}\nexports.PlayerView = PlayerView;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/interactive/PlayerView.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nclass GameResources {\n    /** @brief  Path to resources. */\n    static get ResourcesFolder() {\n        return './resources';\n    }\n    ;\n    /** @brief  Path to image resources. */\n    static get ImagesFolder() {\n        return GameResources.ResourcesFolder + '/img';\n    }\n    ;\n    /** @brief  Path to fonts resources. */\n    static get FontsFolder() {\n        return GameResources.ResourcesFolder + '/fonts';\n    }\n    ;\n    /** @brief  Path to the sprite texture of the shadow. */\n    static get ShadowPath() {\n        return GameResources.ImagesFolder + '/Shadow.png';\n    }\n}\nexports.GameResources = GameResources;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/GameResources.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nconst PlayerViewModule = require(\"../views/screens/game/interactive/PlayerView\");\nconst PlayerModelModule = require(\"../models/interactive/players/Player\");\nconst JumpPlayerModelModule = require(\"../models/interactive/players/Jump\");\nconst BehaviorPlayerModelModule = require(\"../models/interactive/players/Behavior\");\n/**\n * @brief   Data to set up a Player.\n */\nclass PlayerSetupData {\n    /** @brief  Create a new instance of PlayerSetupData. */\n    constructor() { }\n    /** @brief  Get and set the position of the Player. */\n    get Position() { return this.m_position; }\n    set Position(position) { this.m_position = position.clone(); }\n    /** @brief  Get and set the area in which the Player can move. */\n    get Area() { return this.m_area; }\n    set Area(area) { this.m_area = area.clone(); }\n    /** @brief  Get and set the speed factor to move the Player. */\n    get SpeedFactor() { return this.m_speedFactor; }\n    set SpeedFactor(factor) { this.m_speedFactor = factor; }\n    /** @brief  Get and set the max score to make the Player win. */\n    get MaxScore() { return this.m_maxScore; }\n    set MaxScore(score) { this.m_maxScore = score; }\n    /** @brief  Get and set the texture of the Player. */\n    get Texture() { return this.m_texture; }\n    set Texture(texture) { this.m_texture = texture; }\n    /**\n     * @brief  Get the real position of the Player using both provided position\n     *         and the height of the player sprite.\n     */\n    get RealPosition() {\n        return new PIXI.Point(this.m_position.x - (this.m_texture.width / 2), this.m_position.y - this.m_texture.height);\n    }\n}\nexports.PlayerSetupData = PlayerSetupData;\n;\n/**\n * @brief   Controller of a Player.\n */\nclass PlayerController {\n    /**\n     * @brief   Create a new instance of PlayerController.\n     * @param   position    Position of the PlayerView sprite when created.\n     */\n    constructor(data) {\n        this.setModel(data);\n        this.setTexture(data);\n        addEventListener(BehaviorPlayerModelModule.Behavior.MovePlayerUpdateEvent, this.updateView.bind(this));\n        addEventListener(JumpPlayerModelModule.Jump.JumpPlayerUpdateEvent, this.updateView.bind(this));\n    }\n    /**\n     * @brief   Set the model of the Player.\n     */\n    setModel(data) {\n        this.m_model = new PlayerModelModule.Player(data.RealPosition, data.SpeedFactor, data.MaxScore);\n    }\n    /**\n     * @brief   Set the texture of the Player. Can be changed while playing.\n     * @param   texture     Path to the texture of the Player.\n     */\n    setTexture(data) {\n        var position = this.m_model.Behavior.CurrentPosition;\n        this.m_view = new PlayerViewModule.PlayerView(data.Texture, position);\n        data.Area.width -= data.Texture.width;\n        this.m_model.Behavior.setBounds(data.Area);\n        this.m_model.Behavior.AABB = new PIXI.Rectangle(0, 0, data.Texture.width, data.Texture.height);\n    }\n    /**\n     * @brief   Update the view to fit model data.\n     */\n    updateView() {\n        this.m_view.moveAt(this.m_model.Behavior.CurrentPosition);\n    }\n    /**\n     * @brief   Update the Player.\n     */\n    update() {\n        if (this.m_model != undefined) {\n            this.m_model.update();\n        }\n    }\n    /**\n     * @brief   Move the Player on left.\n     */\n    moveLeft() {\n        if (this.m_model != undefined) {\n            this.m_model.Behavior.moveLeft();\n        }\n    }\n    /**\n     * @brief   Move the Player on right.\n     */\n    moveRight() {\n        if (this.m_model != undefined) {\n            this.m_model.Behavior.moveRight();\n        }\n    }\n    /**\n     * @brief   Make the Player jump.\n     */\n    jump() {\n        if (this.m_model != undefined) {\n            this.m_model.jump();\n        }\n    }\n    /**\n     * @brief   Get the view of the Player.\n     * @return  View of the Player.\n     */\n    get View() {\n        return this.m_view;\n    }\n}\nexports.PlayerController = PlayerController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/controllers/PlayerController.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nconst BehaviorModule = require(\"./Behavior\");\nconst JumpModule = require(\"./Jump\");\nconst ScoringModule = require(\"./Scoring\");\n/**\n * @brief   A Player is an entity that is controlled by the user.\n */\nclass Player {\n    /**\n     * @brief   Create a new Player.\n     * @param   texture     Path to the image of the Player.\n     * @param   position    Position of the Player when created.\n     * @param   speed       Speed of the Player when moving.\n     * @param   maxScore    Score to make Player win.\n     */\n    constructor(position, speedFactor, maxScore) {\n        this.m_scoring = new ScoringModule.Scoring(maxScore);\n        this.m_behavior = new BehaviorModule.Behavior(position, speedFactor);\n        this.m_jump = new JumpModule.Jump(this.m_behavior.CurrentPosition, this.m_behavior.Speed);\n        this.m_behavior.add();\n    }\n    /**\n     * @brief   Make player jump.\n     */\n    jump() {\n        this.m_jump.trigger();\n    }\n    /** @brief  Make the player score one point. */\n    score() {\n        this.m_scoring.score(1);\n    }\n    /**\n     * @brief   Get the force applied on the player when jumping.\n     */\n    get JumpForce() {\n        return this.m_jump.Force;\n    }\n    /**\n     * @brief   Get the behavior of the Player.\n     */\n    get Behavior() {\n        return this.m_behavior;\n    }\n    /** @brief  Set the AABB of the Ball. */\n    set AABB(aabb) {\n        this.m_behavior.AABB = aabb;\n    }\n    /**\n     * Get the score of the Player.\n     * @return {number} Current score of the Player.\n     */\n    get ScorePoints() {\n        return this.m_scoring.CurrentPoints;\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        this.m_jump.update();\n        this.Behavior.update();\n    }\n}\nexports.Player = Player;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/players/Player.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\nconst KinematicBodyModule = require(\"../../physics/KinematicBody\");\n/**\n * @brief   Behavior of a Player.\n */\nclass Behavior extends KinematicBodyModule.KinematicBody {\n    /** @brief  Event for moving player update position. */\n    static get MovePlayerUpdateEvent() { return 'MovePlayer'; }\n    /** @brief  Default speed to make Player move. */\n    static get DefaultSpeed() { return 12; }\n    /**\n     * @brief   Create a new Behavior.\n     * @param   startPosX   Position on X axis of the Player when created.\n     * @param   speed       Speed of the Player when moving.\n     */\n    constructor(position, speedFactor) {\n        super(new PIXI.Point(position.x, position.y));\n        this.m_moveForce = 0;\n        this.m_initialPosition = new PIXI.Point(position.x, position.y);\n        this.m_speedFactor = Behavior.DefaultSpeed * speedFactor;\n    }\n    /**\n     * @brief   Set the bounds of the player.\n     * @param   bounds      Amount of pixel on left and right in which the\n     *                      player can move.\n     */\n    setBounds(bounds) {\n        this.m_minBound = bounds.x;\n        this.m_maxBound = bounds.x + bounds.width;\n        console.assert(this.m_minBound < this.m_maxBound);\n    }\n    /**\n     * @brief   Update the Player behavior.\n     */\n    update() {\n        this.CurrentPosition.x += this.m_moveForce;\n        this.m_moveForce = 0;\n        // Clamp the Player position.\n        if (this.CurrentPosition.x < this.MinBound) {\n            this.CurrentPosition.x = this.MinBound;\n        }\n        else if (this.CurrentPosition.x > this.MaxBound) {\n            this.CurrentPosition.x = this.MaxBound;\n        }\n        dispatchEvent(new Event(Behavior.MovePlayerUpdateEvent));\n    }\n    /**\n     * @brief   Move Player on left.\n     */\n    moveLeft() {\n        if (this.CurrentPosition.x > this.MinBound) {\n            this.m_moveForce = -this.SpeedFactor;\n            this.SpeedX = this.m_moveForce;\n        }\n        else {\n            this.m_moveForce = 0;\n        }\n    }\n    /**\n     * @brief   Move Player on right.\n     */\n    moveRight() {\n        if (this.CurrentPosition.x < this.MaxBound) {\n            this.m_moveForce = this.SpeedFactor;\n            this.SpeedX = this.m_moveForce;\n        }\n        else {\n            this.m_moveForce = 0;\n        }\n    }\n    /**\n     * @brief   Reset the position of the Player.\n     */\n    resetPosition() {\n        this.CurrentPosition.x = this.m_initialPosition.x;\n        this.CurrentPosition.y = this.m_initialPosition.y;\n    }\n    /**\n     * @brief   Get the minimal coordinate on X axis the player can reach.\n     */\n    get MinBound() {\n        return this.m_minBound;\n    }\n    /**\n     * @brief   Get the maximal coordinate on X axis the player can reach.\n     */\n    get MaxBound() {\n        return this.m_maxBound;\n    }\n    /**\n     * @brief   Get the speed of the player.\n     */\n    get SpeedFactor() {\n        return this.m_speedFactor;\n    }\n    /**\n     * @brief   Set the speed of the player.\n     */\n    set SpeedFactor(speedFactor) {\n        this.m_speedFactor = speedFactor;\n    }\n    /**\n     * @brief   Get the force applied on the Player when moving.\n     */\n    get MoveForce() {\n        return this.m_moveForce;\n    }\n}\nexports.Behavior = Behavior;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/players/Behavior.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\nconst PhysicsEventsModule = require(\"./PhysicsEvents\");\nlet PhysicsEvents = PhysicsEventsModule.PhysicsEvents;\n/**\n * @brief   A KinematicBody is a movable entity that is not affected by forces\n *          but can collide with RigidBody instances.\n */\nclass KinematicBody {\n    /**\n     * @brief   Instanciation of a new KinematicBody.\n     * @param   aabb    Bounding box of the KinematicBody.\n     */\n    constructor(position, aabb) {\n        if (aabb != undefined) {\n            this.m_aabb = aabb;\n        }\n        else {\n            this.m_aabb = new PIXI.Rectangle(0, 0, 0, 0);\n        }\n        this.m_currentPosition = position;\n        this.m_speed = new PIXI.Point(0, 0);\n    }\n    /**\n     * @brief  Add the RigidBody to the physics engine.\n     */\n    add() {\n        this.register();\n    }\n    /**\n     * @brief   Remove the RigidBody from the physics engine.\n     */\n    remove() {\n        this.unregister();\n    }\n    /** @brief  Register the KinematicBody to the PhysicsEngine. */\n    register() {\n        const RegisterObstacle = PhysicsEvents.RegisterObstacleEvent;\n        var event;\n        event = new CustomEvent(RegisterObstacle, { 'detail': this });\n        dispatchEvent(event);\n    }\n    /** @brief  Unregister the KinematicBody from the PhysicsEngine. */\n    unregister() {\n        const UnregisterObstacle = PhysicsEvents.UnregisterObstacleEvent;\n        var event;\n        event = new CustomEvent(UnregisterObstacle, { 'detail': this });\n        dispatchEvent(event);\n    }\n    /**\n     * @brief   Get the current position of the Player.\n     */\n    get CurrentPosition() {\n        return this.m_currentPosition;\n    }\n    /** @brief  Get the speed of the Kinematic Body on both X and Y axes. */\n    get Speed() {\n        return this.m_speed;\n    }\n    /** @brief  Get the speed of the KinematicBody on X axis. */\n    get SpeedX() {\n        return this.m_speed.x;\n    }\n    /** @brief  Set the speed of the KinematicBody on X axis. */\n    set SpeedX(x) {\n        this.m_speed.x = x;\n    }\n    /** @brief  Get the speed of the KinematicBody on Y axis. */\n    get SpeedY() {\n        return this.m_speed.y;\n    }\n    /** @brief  Set the speed of the KinematicBody on Y axis. */\n    set SpeedY(y) {\n        this.m_speed.y = y;\n    }\n    /** @brief  Get the AABB of the KinematicBody. */\n    get AABB() {\n        return this.m_aabb;\n    }\n    /** @brief  Set the AABB of the KinematicBody. */\n    set AABB(aabb) {\n        this.m_aabb = aabb;\n    }\n}\nexports.KinematicBody = KinematicBody;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/physics/KinematicBody.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\n/**\n * Events for physics engine.\n */\nclass PhysicsEvents {\n    /** @brief  Event to register a RigidBody. */\n    static get RegisterRigidBodyEvent() { return 'RegisterRigidBody'; }\n    /** @brief  Event to unregister a RigidBody. */\n    static get UnregisterRigidBodyEvent() { return 'UnregisterRigidBody'; }\n    /** @brief  Event to register an Obstacle. */\n    static get RegisterObstacleEvent() { return 'RegisterObstacle'; }\n    /** @brief  Event to unregister an Obstacle. */\n    static get UnregisterObstacleEvent() { return 'UnregisterObstacle'; }\n}\nexports.PhysicsEvents = PhysicsEvents;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/physics/PhysicsEvents.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\n/**\n * @brief   Make the player jump.\n */\nclass Jump {\n    /** @brief  Event for jumping player update position. */\n    static get JumpPlayerUpdateEvent() { return 'JumpPlayer'; }\n    /** @brief  Initial jump force when a jump is started. */\n    static get InitialJumpForce() { return -14; }\n    /** @brief  Decrease of the jump force. */\n    static get JumpForceDecrease() { return 0.7; }\n    /** @brief  Maximum amount of jumps that can be made at the same time. */\n    static get MaxJumps() { return 2; }\n    static get AmountFrameBeforeJump() { return 16; }\n    /** @brief  Create a Jump behavior for Player. */\n    constructor(position, speed) {\n        this.m_position = position;\n        this.m_onGroundPosition = position.y;\n        this.m_speed = speed;\n        this.m_amountJumps = 0;\n        this.m_speed.y = 0;\n        this.m_shouldUpdateJumpOnUpdate = false;\n        // Used to enable the first jump.\n        this.m_framesSinceLastJump = Jump.AmountFrameBeforeJump;\n    }\n    /** @brief  Trigger the jump. */\n    trigger() {\n        if ((this.m_framesSinceLastJump >= Jump.AmountFrameBeforeJump)\n            && (this.m_amountJumps < Jump.MaxJumps)) {\n            this.m_speed.y = Jump.InitialJumpForce;\n            this.m_amountJumps++;\n            this.m_framesSinceLastJump = 0;\n            if (this.m_amountJumps == 1) {\n                this.m_shouldUpdateJumpOnUpdate = true;\n            }\n        }\n    }\n    /** @brief  Refresh the jump position of the player. */\n    updateJump() {\n        this.m_position.y += this.m_speed.y;\n        this.m_speed.y += Jump.JumpForceDecrease;\n        dispatchEvent(new Event(Jump.JumpPlayerUpdateEvent));\n        if (this.m_position.y < this.m_onGroundPosition) {\n            this.m_framesSinceLastJump++;\n            this.m_shouldUpdateJumpOnUpdate = true;\n        }\n        else {\n            this.m_position.y = this.m_onGroundPosition;\n            this.m_amountJumps = 0;\n            this.m_speed.y = 0;\n            this.m_framesSinceLastJump = Jump.AmountFrameBeforeJump;\n            this.m_shouldUpdateJumpOnUpdate = false;\n        }\n    }\n    /** @brief  Get the force applied on Player for jumping. */\n    get Force() {\n        return this.m_speed.y;\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        if (this.m_shouldUpdateJumpOnUpdate) {\n            this.updateJump();\n        }\n    }\n}\nexports.Jump = Jump;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/players/Jump.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\n/**\n * @brief   Manage the scoring of a Player.\n */\nclass Scoring {\n    /** @brief  Default max score to make Player win. */\n    static get DefaultMaxPoints() {\n        return 15;\n    }\n    /**\n     * @brief   Create a new instance of Scoring.\n     * @param   maxPoints   Score to make Player win.\n     */\n    constructor(maxPoints) {\n        this.m_points = 0;\n        if (maxPoints != null) {\n            this.m_maxPoints = maxPoints;\n        }\n        else {\n            this.m_maxPoints = Scoring.DefaultMaxPoints;\n        }\n    }\n    /**\n     * @brief   Make the Player score.\n     * @param   points  Amount of points the Player has won.\n     * @return  TRUE if the player has won the game, FALSE if not.\n     */\n    score(points) {\n        this.m_points += points;\n        return (this.m_points >= this.m_maxPoints);\n    }\n    /**\n     * @brief   Get the score of the player.\n     */\n    get CurrentPoints() {\n        return this.m_points;\n    }\n}\nexports.Scoring = Scoring;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/players/Scoring.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nconst ResourcesModule = require(\"../GameResources\");\nlet Resources = ResourcesModule.GameResources;\nconst GeometryModule = require(\"../../../../utils/Geometry\");\nlet Geometry = GeometryModule.Geometry;\n/**\n * @brief   Graphical representation of the Ball.\n */\nclass BallView {\n    /** @brief  Event sent when the ball data are loaded. */\n    static get BallLoadedEvent() {\n        return 'BallLoaded';\n    }\n    /** @brief  Base rotation speed. */\n    static get BaseRotationSpeed() { return 0.01; }\n    /** @brief  Path to the sprite texture of the ball. */\n    static get BallPath() {\n        return Resources.ImagesFolder + '/Ball.png';\n    }\n    /**\n     * @brief  Create a new instance of the BallView.\n     * @param   texture     Texture of the BallView.\n     * @param   position    Position of the BallView sprite when created.\n     */\n    constructor(texture, position) {\n        this.m_yOnGround = position.y;\n        this.m_ballSprite = new PIXI.Sprite(texture);\n        this.m_ballSprite.pivot = Geometry.GetCenter(this.m_ballSprite.getLocalBounds());\n        this.m_shadowSprite = new PIXI.Sprite(Resources.ShadowTexture);\n        this.m_shadowSprite.position.y = position.y - (this.m_ballSprite.width / 2);\n        this.moveAt(position);\n    }\n    /** @brief  Preload ball textures in order to synchronize loadings. */\n    static PreloadSprites() {\n        var assetsLoader = new PIXI.loaders.Loader();\n        assetsLoader.add('Ball', BallView.BallPath);\n        assetsLoader.add('Shadow', Resources.ShadowPath);\n        assetsLoader.once('complete', BallView.OnAssetsLoaded.bind(this));\n        assetsLoader.load();\n    }\n    /**\n     * @brief   Send an event to the game view once all resources on BallView\n     *          are loaded.\n     */\n    static OnAssetsLoaded() {\n        BallView.ShadowXOffset = Resources.ShadowTexture.width / 2;\n        dispatchEvent(new Event(BallView.BallLoadedEvent));\n    }\n    /**\n     * @brief   Move the sprite of the BallView at the given position.\n     * @param   position    Position of the ball.\n     */\n    moveAt(position) {\n        this.m_ballSprite.position.x = position.x;\n        this.m_ballSprite.position.y = position.y;\n        this.m_shadowSprite.position.x = this.m_ballSprite.position.x - BallView.ShadowXOffset;\n        this.m_shadowSprite.alpha = Math.max(0.2, position.y / this.m_yOnGround);\n    }\n    /**\n     * Rotate the sprite of the ball.\n     * @param {number} angle Angle to apply to the sprite.\n     */\n    rotate(angle) {\n        this.m_ballSprite.rotation = angle;\n    }\n    /**\n     * @brief   Get sprite of the Ball.\n     * @return  Sprite of the Ball.\n     */\n    get BallSprite() {\n        return this.m_ballSprite;\n    }\n    /**\n     * @brief   Get sprite of the Player shadow.\n     * @return  Sprite of the Player shadow.\n     */\n    get ShadowSprite() {\n        return this.m_shadowSprite;\n    }\n}\nexports.BallView = BallView;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/interactive/BallView.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\n/**\n * Axis and direction.\n */\nvar Axis;\n(function (Axis) {\n    Axis[Axis[\"None\"] = 0] = \"None\";\n    Axis[Axis[\"PlusX\"] = 1] = \"PlusX\";\n    Axis[Axis[\"PlusY\"] = 2] = \"PlusY\";\n    Axis[Axis[\"MinusX\"] = 17] = \"MinusX\";\n    Axis[Axis[\"MinusY\"] = 18] = \"MinusY\";\n})(Axis = exports.Axis || (exports.Axis = {}));\n;\nclass Geometry {\n    /**\n     * @brief   Check if two rectangles intersect.\n     * @param   first   First rectangle.\n     * @param   second  Second rectangle\n     * @return  TRUE if the rectangles intersect, FALSE otherwise.\n     */\n    static Intersect(first, second) {\n        // If the rectangle has no area, no intersection is possible.\n        if (first.width <= 0 || first.height <= 0) {\n            return false;\n        }\n        // If the rectangle has no area, no intersection is possible.\n        if (second.width <= 0 || second.height <= 0) {\n            return false;\n        }\n        var x0 = first.x;\n        var y0 = first.y;\n        var x1 = second.x;\n        var y1 = second.y;\n        return (x1 + second.width > x0)\n            && (y1 + second.height > y0)\n            && (x1 < x0 + first.width)\n            && (y1 < y0 + first.height);\n    }\n    /**\n     * Check if a point is outside a rectangle. The returned value indicates on\n     * which axes the point is ouside compared to the center of the rectangle.\n     * @param  {PIXI.Point}     pt  The point to check if it is outside.\n     * @param  {PIXI.Rectangle} rec The rectangle for which the point is tested.\n     * @return {Array<Axis>}        Axes on which the point is outside the\n     *                              rectangle.\n     */\n    static IsOutside(pt, rec) {\n        var result = new Array();\n        // Is the point outside on X axis?\n        if (pt.x < (rec.x)) {\n            result.push(Axis.MinusX);\n        }\n        else if (pt.x > (rec.x + rec.width)) {\n            result.push(Axis.PlusX);\n        }\n        // Is the point outside on Y axis?\n        if (pt.y < (rec.y)) {\n            result.push(Axis.MinusY);\n        }\n        else if (pt.y > (rec.y + rec.height)) {\n            result.push(Axis.PlusY);\n        }\n        return result;\n    }\n    /**\n     * Get the center of a rectangle. This is based on the position of the\n     * rectangle.\n     * @param  {PIXI.Rectangle} rec The rectangle to get center of.\n     * @return {PIXI.Point}         The center point of the rectangle.\n     */\n    static GetCenter(rec) {\n        var topX = rec.x;\n        var bottomX = rec.x + rec.width;\n        var centerX = (bottomX + topX) / 2;\n        var topY = rec.y;\n        var bottomY = rec.y + rec.height;\n        var centerY = (bottomY + topY) / 2;\n        return new PIXI.Point(centerX, centerY);\n    }\n    /**\n     * @brief   Get the alignement of two rectangles as a float value.\n     *          This value is a ratio, alignment of second rectangle over the\n     *          height of the first one.\n     *          The ratio is:\n     *              - zero when the two rectangles are perfectly aligned on\n     *                vertical axis;\n     *              - negative if the second rectangle is under the first one;\n     *              - positive if the second rectangle is over the first one.\n     * @param   first   First rectangle.\n     * @param   second  Second rectangle.\n     * @return  The ratio that indicates the position of the second rectangle\n     *          relatively to the first one.\n     */\n    static VerticalContact(first, second) {\n        var yCenter0 = first.y + (first.height / 2);\n        var yCenter1 = second.y + (second.height / 2);\n        var ratio = (yCenter1 - yCenter0) / first.height;\n        return ratio;\n    }\n    /**\n     * @brief   Get the alignement of two rectangles as a float value.\n     *          This value is a ratio, alignment of second rectangle over the\n     *          width of the first one.\n     *          The ratio is:\n     *              - zero when the two rectangles are perfectly aligned on\n     *                horizontal axis;\n     *              - negative if the second rectangle is under the first one;\n     *              - positive if the second rectangle is over the first one.\n     * @param   first   First rectangle.\n     * @param   second  Second rectangle.\n     * @return  The ratio that indicates the position of the second rectangle\n     *          relatively to the first one.\n     */\n    static HorizontalContact(first, second) {\n        var xCenter0 = first.x + (first.width / 2);\n        var xCenter1 = second.x + (second.width / 2);\n        var ratio = (xCenter1 - xCenter0) / first.width;\n        return -ratio;\n    }\n}\nexports.Geometry = Geometry;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/Geometry.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nconst BallViewModule = require(\"../views/screens/game/interactive/BallView\");\nconst BallModule = require(\"../models/interactive/balls/Ball\");\n/**\n * @brief   Data to set up a Ball.\n */\nclass BallSetupData {\n    /** @brief  Create a new instance of BallSetupData. */\n    constructor() { }\n    /** @brief  Get and set the position of the Ball. */\n    get Position() { return this.m_position; }\n    set Position(position) { this.m_position = position.clone(); }\n    /** @brief  Get and set the area in which the Ball can move. */\n    get Area() { return this.m_area; }\n    set Area(area) { this.m_area = area.clone(); }\n    /** @brief  Get and set the speed factor to move the Ball. */\n    get SpeedFactor() { return this.m_speedFactor; }\n    set SpeedFactor(factor) { this.m_speedFactor = factor; }\n}\nexports.BallSetupData = BallSetupData;\n;\n/**\n * @brief   Controller of a Ball.\n */\nclass BallController {\n    /**\n     * @brief   Create a new instance of BallController.\n     * @param   position    Position of the BallView sprite when created.\n     */\n    constructor(data) {\n        this.setTexture(data);\n        this.setModel(data);\n    }\n    /**\n     * @brief   General update of the Ball.\n     */\n    update() {\n        this.m_model.update();\n        this.m_view.moveAt(this.m_model.CenterPosition);\n        this.m_view.rotate(this.m_model.SpeedY / 2);\n    }\n    /**\n     * Reset the position of the Ball.\n     * @param {PIXI.Point} position The new position of the Ball.\n     */\n    reset(position) {\n        this.m_model.reset(position);\n        this.m_view.moveAt(this.m_model.CenterPosition);\n    }\n    /**\n     * @brief   Set the model of the Ball.\n     */\n    setModel(data) {\n        this.m_model = new BallModule.Ball(data.Position, data.Area);\n        this.m_model.AABB = this.m_view.BallSprite.getBounds();\n    }\n    /**\n     * @brief   Set the texture of the Ball. Can be changed while playing.\n     * @param   texture     Path to the texture of the Ball.\n     */\n    setTexture(data) {\n        var texturePath = BallViewModule.BallView.BallPath;\n        var texture = PIXI.Texture.fromImage(texturePath);\n        this.m_view = new BallViewModule.BallView(texture, data.Position);\n        data.Area.width -= this.m_view.BallSprite.width;\n    }\n    /**\n     * @brief   Get the view of the Ball.\n     * @return  View of the Ball.\n     */\n    get View() {\n        return this.m_view;\n    }\n}\nexports.BallController = BallController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/controllers/BallController.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\nconst PhysicsModule = require(\"./BallPhysics\");\nconst GeometryModule = require(\"../../../utils/Geometry\");\nlet Geometry = GeometryModule.Geometry;\nclass Ball {\n    /** @brief  Create a new Ball instance. */\n    constructor(position, area) {\n        this.m_physics = new PhysicsModule.BallPhysics(position, area);\n        this.m_physics.add();\n    }\n    /**\n     * @brief   Update the ball logics.\n     */\n    update() {\n        if (this.m_physics.IsOnGround) {\n        }\n    }\n    /**\n     * @brief   Reset the Ball at the provided position.\n     * @param   position    Position at which the Ball is put.\n     */\n    reset(position) {\n        this.m_physics.Position.x = position.x;\n        this.m_physics.Position.y = position.y;\n    }\n    /** @brief  Get the position of the Ball. */\n    get Position() {\n        return this.m_physics.Position;\n    }\n    /** @brief  Get the center position of the Ball. */\n    get CenterPosition() {\n        var center = Geometry.GetCenter(this.m_physics.AABB);\n        var centerAbsolute = new PIXI.Point();\n        centerAbsolute.x = center.x + this.m_physics.Position.x;\n        centerAbsolute.y = center.y + this.m_physics.Position.y;\n        return centerAbsolute;\n    }\n    /**\n     * Get the speed of the ball on Y axis.\n     * @return {number} Speed of the ball on Y axis.\n     */\n    get SpeedY() {\n        return this.m_physics.Force.y;\n    }\n    /** @brief  Set the AABB of the Ball. */\n    set AABB(aabb) {\n        this.m_physics.AABB = aabb;\n    }\n}\nexports.Ball = Ball;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/balls/Ball.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\nconst RigidBodyModule = require(\"../../physics/RigidBody\");\n/**\n * @brief   Class to handle the physics of the Ball.\n */\nclass BallPhysics extends RigidBodyModule.RigidBody {\n    /** @brief  Weight of the Ball. */\n    static get Weigth() { return 0.27; }\n    /** @brief  Decrease of the force on Y axis. */\n    static get ForceDecrease() { return 0.5; }\n    /** @brief  Maximal force toward ground that can be applied to the ball. */\n    static get MaxForceDown() { return -16; }\n    /** @brief  Maximal force on sides that can be applied to the ball. */\n    static get MaxForceLateral() { return 5; }\n    /** @brief  Friction of the ground of Ball. */\n    static get GroundFriction() { return 0.7; }\n    /**\n     * @brief   Coefficient of restitution to make the Ball bounce.\n     *          To be set between 0 and 1 for realistic physics (!).\n     *          Default restitution of a true volley ball on a steel surface.\n     *          See Principles of Biomechanics and Motion Analysis,\n     *          Iwan W. Griffiths.\n     */\n    static get Restitution() { return 0.76; }\n    /**\n     * @brief  Create a new Ball physics instance.\n     * @param   position    Initial position of the object.\n     * @param   area        Area in which the object can move.\n     */\n    constructor(position, area) {\n        super(area, BallPhysics.Weigth, BallPhysics.Restitution);\n        this.OpenHeight = true;\n        this.setPosition(position);\n    }\n}\nexports.BallPhysics = BallPhysics;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/balls/BallPhysics.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\nconst PhysicsEventsModule = require(\"./PhysicsEvents\");\nlet PhysicsEvents = PhysicsEventsModule.PhysicsEvents;\n/**\n * @brief   A RigidBody is an entity that is submitted to physics (gravity,\n *          forces, etc).\n */\nclass RigidBody {\n    /**\n     * @brief   Instanciation of a new RigidBody.\n     * @param   area        Area in which the RigidBody can move.\n     * @param   weigth      Weigth of the RigidBody.\n     * @param   restitution Coefficient of restitution to make the RigidBody\n     *                      bounce.\n     */\n    constructor(area, weigth, restitution) {\n        this.m_area = area;\n        this.m_weight = weigth;\n        this.m_restitution = restitution;\n        this.m_isOnGround = false;\n        this.m_force = new PIXI.Point(0, 0);\n        this.m_position = new PIXI.Point(0, 0);\n    }\n    /**\n     * @brief  Add the RigidBody to the physics engine.\n     */\n    add() {\n        this.register();\n    }\n    /**\n     * @brief   Remove the RigidBody from the physics engine.\n     */\n    remove() {\n        this.unregister();\n    }\n    /** @brief  Register the RigidBody to the PhysicsEngine. */\n    register() {\n        const RegisterRigidBody = PhysicsEvents.RegisterRigidBodyEvent;\n        var event;\n        event = new CustomEvent(RegisterRigidBody, { 'detail': this });\n        dispatchEvent(event);\n    }\n    /** @brief  Unregister the RigidBody from the PhysicsEngine. */\n    unregister() {\n        const UnregisterRigidBody = PhysicsEvents.UnregisterRigidBodyEvent;\n        var event;\n        event = new CustomEvent(UnregisterRigidBody, { 'detail': this });\n        dispatchEvent(event);\n    }\n    /**\n     * @brief   Update the position of the RigidBody on X axis.\n     * @param   x   Position of the RigidBody on X axis.\n     */\n    updatePositionOnX(x) {\n        this.m_position.x = x;\n    }\n    /**\n     * @brief   Update the position of the RigidBody on Y axis.\n     * @param   x   Position of the RigidBody on Y axis.\n     */\n    updatePositionOnY(y) {\n        this.m_position.y = y;\n        var bottom = this.Position.y + this.AABB.height;\n        if (bottom >= this.Area.height) {\n            this.Force.y = 0;\n            this.Position.y = this.Area.height - this.AABB.height;\n            this.m_isOnGround = true;\n        }\n        else {\n            this.m_isOnGround = false;\n        }\n    }\n    /** @brief  Get the position of the RigidBody. */\n    get Position() {\n        return this.m_position;\n    }\n    /** @brief  Set the position of the RigidBody. */\n    setPosition(position) {\n        this.m_position = position.clone();\n    }\n    /** @brief  Get the AABB of the RigidBody. */\n    get AABB() {\n        return this.m_aabb;\n    }\n    /** @brief  Set the AABB of the RigidBody. */\n    set AABB(aabb) {\n        this.m_aabb = aabb;\n    }\n    /** @brief  Get the area in which the RigidBody can move. */\n    get Area() {\n        return this.m_area;\n    }\n    /** @brief  Get the force applied on the RigidBody, on axes X and Y. */\n    get Force() {\n        return this.m_force;\n    }\n    /** @brief  Get the weigth of the RigidBody. */\n    get Weigth() {\n        return this.m_weight;\n    }\n    /** @brief  Get the restitution of the RigidBody. */\n    get Restitution() {\n        return this.m_restitution;\n    }\n    /** @brief  Set the restitution of the RigidBody. */\n    set Restitution(restitution) {\n        this.m_restitution = restitution;\n    }\n    /** @brief  If TRUE, no matter if the body exits screen from top. */\n    get OpenHeight() {\n        return this.m_openHeight;\n    }\n    /** @brief  If TRUE, no matter if the body exits screen from top. */\n    set OpenHeight(openHeight) {\n        this.m_openHeight = openHeight;\n    }\n    /** @brief  A RigidBody sleeps when no force is applied on it. */\n    get IsSleeping() {\n        return (this.Force.x == 0)\n            && (this.Force.y == 0)\n            && (this.m_isOnGround);\n    }\n    /** @brief  If TRUE, the RigidBody is on ground. */\n    get IsOnGround() {\n        return this.m_isOnGround;\n    }\n    /** @brief  TRUE if the RigidBody is falling, FALSE otherwise. */\n    get IsFalling() {\n        return this.m_isFalling;\n    }\n    /** @brief  TRUE if the RigidBody is falling, FALSE otherwise. */\n    set IsFalling(falling) {\n        this.m_isFalling = falling;\n    }\n}\nexports.RigidBody = RigidBody;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/physics/RigidBody.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\nconst ResourcesModule = require(\"../GameResources\");\nlet Resources = ResourcesModule.GameResources;\n/**\n * @brief   Graphical representation of the Net.\n */\nclass NetView {\n    /** @brief  Event sent when the Net data are loaded. */\n    static get NetLoadedEvent() {\n        return 'NetLoaded';\n    }\n    /** @brief  Path to the sprite texture of the Net. */\n    static get NetPath() {\n        return Resources.ImagesFolder + '/bg/net.png';\n    }\n    /**\n     * @brief  Create a new instance of the BallView.\n     * @param   texture     Texture of the BallView.\n     * @param   position    Position of the BallView sprite when created.\n     */\n    constructor(texture, position) {\n        this.m_netSprite = new PIXI.Sprite(texture);\n        this.m_netSprite.position.x = position.x;\n        this.m_netSprite.position.y = position.y;\n    }\n    /** @brief  Preload net textures in order to synchronize loadings. */\n    static PreloadSprites() {\n        var assetsLoader = new PIXI.loaders.Loader();\n        assetsLoader.add('Net', NetView.NetPath);\n        assetsLoader.once('complete', NetView.OnAssetsLoaded);\n        assetsLoader.load();\n    }\n    /**\n     * @brief   Send an event to the game view once all resources on NetView\n     *          are loaded.\n     */\n    static OnAssetsLoaded() {\n        dispatchEvent(new Event(NetView.NetLoadedEvent));\n    }\n    /**\n     * @brief   Get sprite of the Net.\n     * @return  Sprite of the Net.\n     */\n    get NetSprite() {\n        return this.m_netSprite;\n    }\n}\nexports.NetView = NetView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/interactive/NetView.ts\n// module id = 23\n// module chunks = 0","\"use strict\";\nconst NetViewModule = require(\"../views/screens/game/interactive/NetView\");\nconst NetModelModule = require(\"../models/interactive/net/Net\");\n/**\n * @brief   Data to set up a Net.\n */\nclass NetSetupData {\n    /**\n     * Create a new NetSetupData.\n     * @param  {PIXI.Point}   position Position of the Net to create.\n     * @param  {PIXI.Texture} texture  Texture of the Net to create.\n     */\n    constructor(position, texture) {\n        this.m_position = position;\n        this.m_texture = texture;\n    }\n    /** @brief  Get and set the position of the Net. */\n    get Position() { return this.m_position; }\n    /** @brief  Get and set the texture of the Net. */\n    get Texture() { return this.m_texture; }\n    /**\n     * @brief  Get the real position of the Net using both provided position\n     *         and the height of the Net sprite.\n     */\n    get RealPosition() {\n        var realPosition = this.m_position.clone();\n        realPosition.x += this.m_texture.width / 2;\n        return realPosition;\n    }\n}\nexports.NetSetupData = NetSetupData;\n;\n/**\n * @brief   Controller of a Net.\n */\nclass NetController {\n    /**\n     * @brief   Create a new instance of NetController.\n     * @param   data    Required data to setup the net.\n     */\n    constructor(data) {\n        this.setModel(data);\n        this.setTexture(data);\n    }\n    /**\n     * @brief   Set the model of the Net.\n     */\n    setModel(data) {\n        this.m_model = new NetModelModule.Net(data.RealPosition);\n    }\n    /**\n     * @brief   Set the texture of the Net. Can be changed while playing.\n     * @param   texture     Path to the texture of the Net.\n     */\n    setTexture(data) {\n        var position = this.m_model.CurrentPosition;\n        this.m_view = new NetViewModule.NetView(data.Texture, position);\n        this.m_model.AABB = new PIXI.Rectangle(0, 0, data.Texture.width, data.Texture.height);\n    }\n    /**\n     * @brief   Get the view of the Net.\n     * @return  View of the Net.\n     */\n    get View() {\n        return this.m_view;\n    }\n}\nexports.NetController = NetController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/controllers/NetController.ts\n// module id = 24\n// module chunks = 0","\"use strict\";\nconst KinematicBodyModule = require(\"../../physics/KinematicBody\");\n/**\n * @brief   A Net is at the middle of the game area.\n *          Each Player\"has\" to jump to send the ball in the area of its\n *          opponent.\n */\nclass Net extends KinematicBodyModule.KinematicBody {\n    /**\n     * Create a new Net instance and register it to the PhysicsEngine.\n     * @param  {PIXI.Point} position Position of the Net.\n     */\n    constructor(position) {\n        super(position);\n        this.add();\n    }\n}\nexports.Net = Net;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/net/Net.ts\n// module id = 25\n// module chunks = 0","\"use strict\";\nconst OuterWallModelModule = require(\"../models/interactive/net/OuterWall\");\n/**\n * @brief   Controller of a OuterWall.\n */\nclass OuterWallController {\n    /**\n     * Fixed width of the wall.\n     * @return {number} Width of the wall.\n     */\n    static get Width() { return 1; }\n    /**\n     * Fixed height of the wall.\n     * @return {number} Height of the wall.\n     */\n    static get Height() { return Number.MAX_VALUE; }\n    /**\n     * @brief   Create a new instance of OuterWall.\n     * @param   position    Position of the OuterWall.\n     */\n    constructor(position) {\n        this.setModel(position);\n    }\n    /**\n     * @brief   Set the model of the OuterWall.\n     * @param   position    Position of the OuterWall.\n     */\n    setModel(position) {\n        this.m_model = new OuterWallModelModule.OuterWall(position);\n        this.m_model.AABB = new PIXI.Rectangle(0, 0, OuterWallController.Width, OuterWallController.Height);\n    }\n}\nexports.OuterWallController = OuterWallController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/controllers/OuterWallController.ts\n// module id = 26\n// module chunks = 0","\"use strict\";\nconst KinematicBodyModule = require(\"../../physics/KinematicBody\");\n/**\n * @brief   An OuterWall defines the end of the game area. The ball bounces on\n *          them (even if not they are not visible) to stay visible on screen.\n */\nclass OuterWall extends KinematicBodyModule.KinematicBody {\n    /**\n     * Create a new Net instance and register it to the PhysicsEngine.\n     * @param  {PIXI.Point} position Position of the Net.\n     */\n    constructor(position) {\n        super(position);\n        this.add();\n    }\n}\nexports.OuterWall = OuterWall;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/interactive/net/OuterWall.ts\n// module id = 27\n// module chunks = 0","\"use strict\";\nconst ElementDataModule = require(\"../../../../utils/ElementData\");\nlet ElementData = ElementDataModule.ElementData;\nconst ResourcesModule = require(\"../GameResources\");\nlet Resources = ResourcesModule.GameResources;\n/**\n * @brief   Class to manage the background of the game screen.\n */\nclass GameBackground extends PIXI.Container {\n    /** @brief  Event sent when the background is loaded. */\n    static get BackgroundLoadedEvent() {\n        return 'BackgroundLoaded';\n    }\n    /** @brief  Path to the ground texture. */\n    static get GroundTexturePath() {\n        return Resources.ImagesFolder + '/bg/bg.png';\n    }\n    ;\n    /**\n     * @brief   Create a new GameBackground.\n     * @param   width   Width of the scene.\n     * @param   height  Height of the scene.\n     */\n    constructor(width, height) {\n        super();\n        this.m_viewportSize = new PIXI.Point(width, height);\n        var bgAssetsLoader = new PIXI.loaders.Loader();\n        bgAssetsLoader.add('Ground', GameBackground.GroundTexturePath);\n        bgAssetsLoader.once('complete', this.onAssetsLoaded.bind(this));\n        bgAssetsLoader.load();\n    }\n    /**\n     * @brief   Callback when assets are loaded.\n     */\n    onAssetsLoaded() {\n        this.setGround();\n        dispatchEvent(new Event(GameBackground.BackgroundLoadedEvent));\n    }\n    /**\n     * @brief   Set the ground texture.\n     */\n    setGround() {\n        var texture = PIXI.Texture.fromImage(GameBackground.GroundTexturePath);\n        var sprite = new PIXI.Sprite(texture);\n        this.addChild(sprite);\n        sprite.position.y = this.m_viewportSize.y - texture.baseTexture.height;\n    }\n}\nexports.GameBackground = GameBackground;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/GameBackground.ts\n// module id = 28\n// module chunks = 0","\"use strict\";\n/** @brief  Deep copy of element data as position or size. */\nclass ElementData {\n    /**\n     * @brief   Create a new instance of ElementData.\n     *          This copies data from given parameters.\n     * @param   position    Position of the element on screen.\n     * @param   width       Width of the element.\n     * @param   height      Height of the element.\n     */\n    constructor(position, width, height) {\n        this.m_position = new PIXI.Point(position.x, position.y);\n        this.m_size = new PIXI.Point(width, height);\n        this.m_bounds = new PIXI.Rectangle(position.x, position.y, width, height);\n    }\n    /** @brief  Get position of the element on X axis. */\n    get X() {\n        return this.m_position.x;\n    }\n    /** @brief  Get position of the element on Y axis. */\n    get Y() {\n        return this.m_position.y;\n    }\n    /** @brief  Get width of the element. */\n    get Width() {\n        return this.m_size.x;\n    }\n    /** @brief  Get height of the element. */\n    get Height() {\n        return this.m_size.y;\n    }\n    /** @brief  Get the bounds of the element with absolute transformation. */\n    get Bounds() {\n        return this.m_bounds;\n    }\n}\nexports.ElementData = ElementData;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/ElementData.ts\n// module id = 29\n// module chunks = 0","\"use strict\";\nconst ResourcesModule = require(\"../GameResources\");\nlet Resources = ResourcesModule.GameResources;\n/**\n * @brief   Class to manage the HUD on the game screen.\n */\nclass GameHUD extends PIXI.Container {\n    /** @brief  Event sent when the foreground is loaded. */\n    static get HUDLoadedEvent() {\n        return 'GameHUDLoaded';\n    }\n    /** @brief  Default text on left. */\n    static get LeftScoreDefaultText() {\n        return \"Player #1\";\n    }\n    /** @brief  Default text on right. */\n    static get RightScoreDefaultText() {\n        return \"Player #2\";\n    }\n    /**\n     * Create the HUD of the game.\n     * @param  {number} sceneWidth Width of the scene.\n     */\n    constructor(sceneWidth) {\n        super();\n        var assetsLoader = new PIXI.loaders.Loader();\n        assetsLoader.add(\"SomeTimeLater\", Resources.FontsFolder + \"/SomeTimeLater.otf\");\n        assetsLoader.once(\"complete\", this.onLoadedFonts.bind(this, sceneWidth));\n        assetsLoader.load();\n    }\n    /**\n     * Create elements of the HUD that depend on loaded resources.\n     * @param {number} sceneWidth Width of the scene.\n     */\n    onLoadedFonts(sceneWidth) {\n        const TextOffset = 20;\n        // Set the style of the scores.\n        var style = { font: \"32px SomeTimeLater\", fill: \"white\", };\n        // Set the texts of the scores.\n        var textLeft = GameHUD.LeftScoreDefaultText + \" 00\";\n        this.m_leftScoring = new PIXI.Text(textLeft, style);\n        this.m_leftScoring.position.set(TextOffset, TextOffset);\n        this.addChild(this.m_leftScoring);\n        var textRight = GameHUD.RightScoreDefaultText + \" 00\";\n        this.m_rightScoring = new PIXI.Text(textRight, style);\n        this.m_rightScoring.position.set(sceneWidth - TextOffset - this.m_rightScoring.width, TextOffset);\n        this.addChild(this.m_rightScoring);\n        // Notify the HUD is loaded and ready to be updated/rendered.\n        dispatchEvent(new Event(GameHUD.HUDLoadedEvent));\n    }\n    /**\n     * @brief   Update the object.\n     */\n    update() {\n        this.m_leftScoring.text = GameHUD.LeftScoreDefaultText + \" : \" + \"0\";\n        this.m_rightScoring.text = GameHUD.RightScoreDefaultText + \" : \" + \"0\";\n    }\n}\nexports.GameHUD = GameHUD;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/views/screens/game/scene/GameHUD.ts\n// module id = 30\n// module chunks = 0","\"use strict\";\nconst PhysicsEventsModule = require(\"./PhysicsEvents\");\nconst GeometryModule = require(\"../../utils/Geometry\");\nlet PhysicsEvents = PhysicsEventsModule.PhysicsEvents;\nlet Geometry = GeometryModule.Geometry;\n/**\n * @brief   Physics engine to manage rigid bodies in the game.\n */\nclass PhysicsEngine {\n    /** @brief  Friction applied on rigid bodies. */\n    static get Friction() { return 0.01; }\n    /** @brief  Get the gravity force value. */\n    static get GravityForce() { return 9.8; }\n    /** @brief  Threshold to consider no force is applied anymore. */\n    static get NullThreshold() { return 0.1; }\n    /**\n     * @brief   Instanciation of the PhysicsEngine.\n     */\n    constructor() {\n        this.m_gravity = PhysicsEngine.GravityForce;\n        this.m_rigidBodies = [];\n        this.m_obstacles = [];\n        addEventListener(PhysicsEvents.RegisterRigidBodyEvent, this.addRigidBody.bind(this));\n        addEventListener(PhysicsEvents.UnregisterRigidBodyEvent, this.removeRigidBody.bind(this));\n        addEventListener(PhysicsEvents.RegisterObstacleEvent, this.addObstacle.bind(this));\n        addEventListener(PhysicsEvents.UnregisterObstacleEvent, this.removeObstacle.bind(this));\n    }\n    /**\n     * @brief   Update the PhysicsEngine and notify RigidBody instances when\n     *          needed (collision, etc).\n     */\n    update() {\n        for (var rigid of this.m_rigidBodies) {\n            var rigidAbsoluteAABB;\n            {\n                var rigidPosition = rigid.Position;\n                var rigidAABB = rigid.AABB;\n                rigidAbsoluteAABB = this.getAbsoluteAABB(rigidAABB, rigidPosition);\n            }\n            // List of kinematic bodies that are in contact with the rigid body.\n            var obstaclesContact = new Array();\n            var isRigidFalling = true;\n            for (var obstacle of this.m_obstacles) {\n                var kinematicAbsoluteAABB;\n                {\n                    var kinematicPosition = obstacle.CurrentPosition;\n                    var kinematicAABB = obstacle.AABB;\n                    kinematicAbsoluteAABB = this.getAbsoluteAABB(kinematicAABB, kinematicPosition);\n                }\n                if (Geometry.Intersect(rigidAbsoluteAABB, kinematicAbsoluteAABB)) {\n                    obstaclesContact.push(obstacle);\n                    this.avoidIntersection(rigid, rigidAbsoluteAABB, obstacle, kinematicAbsoluteAABB);\n                    var hasContact = this.computeCollision(rigid, rigidAbsoluteAABB, obstacle, kinematicAbsoluteAABB);\n                    isRigidFalling = isRigidFalling && !hasContact;\n                }\n            }\n            // If the rigid body is touched by several kinematic bodies at the\n            // same time, it can generate an instable physics behavior.\n            if (obstaclesContact.length > 1) {\n                this.correctCollisions(rigid, rigidAbsoluteAABB, obstaclesContact);\n            }\n            rigid.IsFalling = isRigidFalling;\n            // Do nothing if the rigid body is sleeping.\n            if (rigid.IsSleeping) {\n                continue;\n            }\n            this.applyForces(rigid);\n        }\n    }\n    /**\n     * @brief   Avoid intersections of rigid body and obstacle: unexpected\n     *          behavior in the physics engine.\n     * @param   rigid                   The rigid body.\n     * @param   rigidAbsoluteAABB       AABB of the rigid body at its absolute\n     *                                  position.\n     * @param   obstacle                The kinematic body.\n     * @param   kinematicAbsoluteAABB   AABB of the kinematic body at its\n     *                                  absolute position.\n     */\n    avoidIntersection(rigid, rigidAbsoluteAABB, obstacle, kinematicAbsoluteAABB) {\n        var centerRigid = Geometry.GetCenter(rigidAbsoluteAABB);\n        var outsideAxes = Geometry.IsOutside(centerRigid, kinematicAbsoluteAABB);\n        if (outsideAxes.length == 1) {\n            // At least one axis on which the center is outside the area of\n            // obstacle.\n            var axis = outsideAxes[0];\n            switch (axis) {\n                case GeometryModule.Axis.PlusX:\n                    var updatedX = obstacle.CurrentPosition.x + obstacle.AABB.width;\n                    rigid.updatePositionOnX(updatedX);\n                    break;\n                case GeometryModule.Axis.MinusX:\n                    var updatedX = obstacle.CurrentPosition.x - rigid.AABB.width;\n                    rigid.updatePositionOnX(updatedX);\n                    break;\n                case GeometryModule.Axis.PlusY:\n                    var updatedY = obstacle.CurrentPosition.y + obstacle.AABB.height;\n                    rigid.updatePositionOnY(updatedY);\n                    break;\n                case GeometryModule.Axis.MinusY:\n                    var updatedY = obstacle.CurrentPosition.y - rigid.AABB.height;\n                    rigid.updatePositionOnY(updatedY);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Correction of the collisions on a rigid body when it is in contact with\n     * several kinematic bodies at the same time.\n     * @param   rigid                   The rigid body.\n     * @param   rigidAbsoluteAABB       AABB of the rigid body at its absolute\n     *                                  position.\n     * @param   obstacles               List of obstacles in contact with the\n     *                                  rigid body.\n     */\n    correctCollisions(rigid, rigidAbsoluteAABB, obstacles) {\n        var fastestDirection = 0;\n        var fastestObstacle = obstacles[0];\n        var slowestObstacle = obstacles[0];\n        // Search for the slowest and the fastest obstacles that are moving in\n        // different directions (where at least one is moving).\n        obstacles.forEach((obstacle) => {\n            fastestDirection = Math.sign(fastestObstacle.SpeedX);\n            var slowestDirection = Math.sign(slowestObstacle.SpeedX);\n            var currentDirection = Math.sign(obstacle.SpeedX);\n            var speedFastest = Math.abs(fastestObstacle.SpeedX);\n            var speedSlowest = Math.abs(slowestObstacle.SpeedX);\n            var speedCurrent = Math.abs(obstacle.SpeedX);\n            if ((speedCurrent > speedFastest)\n                && (currentDirection != slowestDirection)) {\n                fastestObstacle = obstacle;\n            }\n            else if ((speedCurrent < speedSlowest)\n                && (currentDirection != fastestDirection)) {\n                slowestObstacle = obstacle;\n            }\n        });\n        // Put the rigid body above the fastest kinematic body.\n        rigid.updatePositionOnY(fastestObstacle.CurrentPosition.y - rigid.AABB.height);\n        // Apply a force to mimic an expulsion.\n        rigid.Force.y = Math.abs(fastestObstacle.SpeedX);\n    }\n    /**\n     * @brief   Compute the collision between a rigid body and a kinematic body.\n     * @param   rigid                   The rigid body.\n     * @param   rigidAbsoluteAABB       AABB of the rigid body at its absolute\n     *                                  position.\n     * @param   obstacle                The kinematic body.\n     * @param   kinematicAbsoluteAABB   AABB of the kinematic body at its\n     *                                  absolute position.\n     * @return  TRUE if the rigid body falls as the kinematic body is not just\n     *          below (in contact). FALSE if the rigid body does not fall.\n     */\n    computeCollision(rigid, rigidAbsoluteAABB, obstacle, kinematicAbsoluteAABB) {\n        const MaxForce = 10;\n        // Force of X axis.\n        if (!rigid.IsOnGround) {\n            var ratioX = Geometry.HorizontalContact(rigidAbsoluteAABB, kinematicAbsoluteAABB);\n            rigid.Force.x = (ratioX * MaxForce);\n            rigid.Force.x = Math.min(rigid.Force.x, MaxForce);\n        }\n        if (Math.abs(rigid.Force.x) < PhysicsEngine.NullThreshold) {\n            rigid.Force.x = Math.random();\n        }\n        // Force of Y axis.\n        var ratioY = Geometry.VerticalContact(rigidAbsoluteAABB, kinematicAbsoluteAABB);\n        if (Math.abs(obstacle.SpeedY) > PhysicsEngine.NullThreshold) {\n            rigid.Force.y = -Math.abs(obstacle.SpeedY);\n        }\n        else if (Math.abs(ratioY) >= 1) {\n            rigid.Force.y = -rigid.Force.y * rigid.Restitution;\n        }\n        if (Math.abs(rigid.Force.y) < PhysicsEngine.NullThreshold) {\n            rigid.Force.y = 0;\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @brief   Apply forces on a rigid body.\n     * @param   rigid   The rigid body.\n     */\n    applyForces(rigid) {\n        // Apply friction on the ball when it is on ground.\n        if (rigid.IsOnGround) {\n            if (rigid.Force.x > 0) {\n                rigid.Force.x -= PhysicsEngine.Friction;\n            }\n            else if (rigid.Force.x < 0) {\n                rigid.Force.x += PhysicsEngine.Friction;\n            }\n            // Stop completely the ball if the move is close to the\n            // threshold.\n            if (Math.abs(rigid.Force.x) < PhysicsEngine.Friction) {\n                rigid.Force.x = 0;\n            }\n        }\n        // Apply physics on the rigid body.\n        if (rigid.IsFalling) {\n            var momentForce = (this.m_gravity * rigid.Weigth) / 10;\n            rigid.Force.y += momentForce;\n        }\n        rigid.updatePositionOnY(rigid.Position.y + rigid.Force.y);\n        rigid.updatePositionOnX(rigid.Position.x + rigid.Force.x);\n    }\n    /**\n     * Compute the absolute AABB in world transformations.\n     * @param  {PIXI.Rectangle} aabb     The AABB in local transformations.\n     * @param  {PIXI.Point}     position Absolute position of the AABB.\n     * @return {PIXI.Rectangle}          A copy of the AABB, with absolute\n     *                                   position.\n     */\n    getAbsoluteAABB(aabb, position) {\n        var absoluteAABB = aabb.clone();\n        absoluteAABB.x += position.x;\n        absoluteAABB.y += position.y;\n        return absoluteAABB;\n    }\n    /**\n     * @brief   Register a RigidBody to the PhysicsEngine.\n     * @param   event   Event containing the RigidBody to register.\n     */\n    addRigidBody(event) {\n        this.m_rigidBodies.push(event.detail);\n    }\n    /**\n     * @brief   Unregister a RigidBody from the PhysicsEngine.\n     * @param   event   Event containing the RigidBody to unregister.\n     */\n    removeRigidBody(event) {\n        var index = this.m_rigidBodies.indexOf(event.detail);\n        if (index > -1) {\n            this.m_rigidBodies.splice(index, 1);\n        }\n    }\n    /**\n     * @brief   Register an Obstacle to the PhysicsEngine.\n     * @param   event   Event containing the Obstacle to register.\n     */\n    addObstacle(event) {\n        this.m_obstacles.push(event.detail);\n    }\n    /**\n     * @brief   Unregister an Obstacle from the PhysicsEngine.\n     * @param   event   Event containing the Obstacle to unregister.\n     */\n    removeObstacle(event) {\n        var index = this.m_obstacles.indexOf(event.detail);\n        if (index > -1) {\n            this.m_obstacles.splice(index, 1);\n        }\n    }\n}\nexports.PhysicsEngine = PhysicsEngine;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/physics/PhysicsEngine.ts\n// module id = 31\n// module chunks = 0"],"sourceRoot":""}